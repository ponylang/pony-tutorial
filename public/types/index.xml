<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Types on Pony Tutorial</title>
    <link>https://tutorial.ponylang.io/types.html</link>
    <description>Recent content in Types on Pony Tutorial</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://tutorial.ponylang.io/types/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Actors</title>
      <link>https://tutorial.ponylang.io/types/actors.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/types/actors.html</guid>
      <description>An actor is similar to a class, but with one critical difference: an actor can have behaviours.
Behaviours A behaviour is like a function, except that functions are synchronous and behaviours are asynchronous. In other words, when you call a function, the body of the function is executed immediately, and the result of the call is the result of the body of the function. This is just like method invocation in any other object-oriented language.</description>
    </item>
    
    <item>
      <title>Classes</title>
      <link>https://tutorial.ponylang.io/types/classes.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/types/classes.html</guid>
      <description>Just like other object-oriented languages, Pony has classes. A class is declared with the keyword class, and it has to have a name that starts with a capital letter, like this:
class Wombat  Do all types start with a capital letter? Yes! And nothing else starts with a capital letter. So when you see a name in Pony code, you will instantly know whether it&amp;rsquo;s a type or not.</description>
    </item>
    
    <item>
      <title>Primitives</title>
      <link>https://tutorial.ponylang.io/types/primitives.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/types/primitives.html</guid>
      <description>A primitive is similar to a class, but there are two critical differences:
 A primitive has no fields. There is only one instance of a user-defined primitive.  Having no fields means primitives are never mutable. Having a single instance means that if your code calls a constructor on a primitive type, it always gets the same result back (except for built-in &amp;ldquo;machine word&amp;rdquo; primitives, covered below).
What can you use a primitive for?</description>
    </item>
    
    <item>
      <title>The Pony Type System at a Glance</title>
      <link>https://tutorial.ponylang.io/types/at-a-glance.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/types/at-a-glance.html</guid>
      <description>Pony is a statically typed language, like Java, C#, C++, and many others. This means the compiler knows the type of everything in your program. This is different from dynamically typed languages, such as Python, Lua, JavaScript, and Ruby.
Static vs Dynamic: What&amp;rsquo;s the difference? In both kinds of language, your data has a type. So what&amp;rsquo;s the difference?
With a dynamically typed language, a variable can point to objects of different types at different times.</description>
    </item>
    
    <item>
      <title>Traits and Interfaces</title>
      <link>https://tutorial.ponylang.io/types/traits-and-interfaces.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/types/traits-and-interfaces.html</guid>
      <description>Like other object-oriented languages, Pony has subtyping. That is, some types serve as categories that other types can be members of.
There are two kinds of subtyping in programming languages: nominal and structural. They&amp;rsquo;re subtly different, and most programming languages only have one or the other. Pony has both!
Nominal subtyping This kind of subtyping is called nominal because it is all about names.
If you&amp;rsquo;ve done object-oriented programming before, you may have seen a lot of discussion about single inheritance, multiple inheritance, mixins, traits, and similar concepts.</description>
    </item>
    
    <item>
      <title>Type Aliases</title>
      <link>https://tutorial.ponylang.io/types/type-aliases.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/types/type-aliases.html</guid>
      <description>A type alias is just a way to give a different name to a type. This may sound a bit silly: after all, types already have names! However, Pony can express some complicated types, and it can be convenient to have a short way to talk about them.
We&amp;rsquo;ll give a couple examples of using type aliases, just to get the feel of them.
Enumerations One way to use type aliases is to express an enumeration.</description>
    </item>
    
    <item>
      <title>Type Expressions</title>
      <link>https://tutorial.ponylang.io/types/type-expressions.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://tutorial.ponylang.io/types/type-expressions.html</guid>
      <description>The types we&amp;rsquo;ve talked about so far can also be combined in type expressions. If you&amp;rsquo;re used to object-oriented programming, you may not have seen these before, but they are common in functional programming. A type expression is also called an algebraic data type.
There are three kinds of type expression: tuples, unions, and intersections.
Tuples A tuple type is a sequence of types. For example, if we wanted something that was a String followed by a U64, we would write this:</description>
    </item>
    
  </channel>
</rss>